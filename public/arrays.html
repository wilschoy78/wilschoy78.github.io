<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Array Data Structure Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .ui-element {
            pointer-events: auto;
        }
        .slide-content {
            transition: opacity 0.5s ease-in-out;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            align-items: center;
        }
        .slide-text {
            text-align: left;
        }
        .slide-code {
            max-height: 200px;
            overflow-y: auto;
        }
        pre code.hljs {
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="ui-container" class="flex flex-col items-center justify-between p-8">
        <!-- Top Title -->
        <div id="title" class="ui-element text-center">
            <h1 class="text-3xl md:text-5xl font-bold text-cyan-400">Array Data Structures</h1>
            <p class="text-lg md:text-xl text-gray-300">An Interactive 3D Demonstration</p>
        </div>

        <!-- Wrapper for bottom elements -->
        <div class="ui-element flex flex-col items-center space-y-4 w-full">
            <!-- Slides/Description -->
            <div id="slides-container" class="bg-black bg-opacity-50 p-6 rounded-2xl shadow-lg max-w-4xl text-center backdrop-blur-sm w-full">
                <!-- Slides will be injected here by JavaScript -->
            </div>

            <!-- Bottom Controls -->
            <div id="controls" class="w-full max-w-4xl flex items-center justify-center space-x-4">
                 <button id="prev-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed">Previous</button>
                 <button id="next-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 shadow-lg">Next</button>
                 <div id="dynamic-controls" class="flex space-x-4"></div>
                 <button id="reset-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 shadow-lg">Reset</button>
            </div>
        </div>
    </div>

    <script>
        // --- THREE.JS SCENE SETUP ---
        let scene, camera, renderer, ambientLight, directionalLight;
        const boardSlots = [];
        const entryObjects = [];
        const ARRAY_CAPACITY = 10;
        const SLOT_SIZE = 2;
        const SLOT_SPACING = 0.5;

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0a0a1a);
            document.body.insertBefore(renderer.domElement, document.getElementById('ui-container'));

            // Lighting
            ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            createScoreboard();
            animate();
        }

        // --- 3D OBJECT CREATION ---
        function createTextCanvas(text, width, height, color, fontSize = 32) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            context.fillStyle = '#000000';
            context.fillRect(0, 0, width, height);
            context.fillStyle = color;
            context.font = `${fontSize}px Inter`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, width / 2, height / 2);
            return canvas;
        }

        function createEntryObject(name, score) {
            const group = new THREE.Group();

            const bodyGeometry = new THREE.BoxGeometry(SLOT_SIZE * 0.9, SLOT_SIZE * 0.9, SLOT_SIZE * 0.9);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x00aaff, roughness: 0.3, metalness: 0.1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);

            // Name Text
            const nameCanvas = createTextCanvas(name, 512, 256, '#ffffff', 64);
            const nameTexture = new THREE.CanvasTexture(nameCanvas);
            const nameMaterial = new THREE.MeshBasicMaterial({ map: nameTexture, transparent: true });
            const namePlane = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 0.9), nameMaterial);
            namePlane.position.y = 0.25;
            namePlane.position.z = SLOT_SIZE / 2 + 0.01;

            // Score Text
            const scoreCanvas = createTextCanvas(score.toString(), 512, 256, '#ffff00', 80);
            const scoreTexture = new THREE.CanvasTexture(scoreCanvas);
            const scoreMaterial = new THREE.MeshBasicMaterial({ map: scoreTexture, transparent: true });
            const scorePlane = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 0.9), scoreMaterial);
            scorePlane.position.y = -0.4;
            scorePlane.position.z = SLOT_SIZE / 2 + 0.01;

            group.add(body);
            group.add(namePlane);
            group.add(scorePlane);

            group.userData = { name, score, isEntry: true };
            return group;
        }


        function createScoreboard() {
            const totalWidth = ARRAY_CAPACITY * (SLOT_SIZE + SLOT_SPACING) - SLOT_SPACING;
            const startX = -totalWidth / 2;

            for (let i = 0; i < ARRAY_CAPACITY; i++) {
                const geometry = new THREE.BoxGeometry(SLOT_SIZE, SLOT_SIZE / 4, SLOT_SIZE);
                const material = new THREE.MeshStandardMaterial({ color: 0x334155, transparent: true, opacity: 0.3 });
                const slot = new THREE.Mesh(geometry, material);
                const xPos = startX + i * (SLOT_SIZE + SLOT_SPACING);
                slot.position.set(xPos, 0, 0);
                scene.add(slot);
                boardSlots.push(slot);

                // Add index label
                const indexCanvas = createTextCanvas(i.toString(), 128, 128, '#64748b', 64);
                const indexTexture = new THREE.CanvasTexture(indexCanvas);
                const indexMaterial = new THREE.MeshBasicMaterial({ map: indexTexture, transparent: true });
                const indexPlane = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), indexMaterial);
                indexPlane.position.set(xPos, -0.75, SLOT_SIZE / 2);
                scene.add(indexPlane);
            }
        }


        // --- ANIMATION ENGINE ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- PRESENTATION LOGIC ---
        let currentSlide = 0;
        const slides = [
            {
                title: "The Scoreboard Array",
                text: "We begin with an empty array of a fixed size. The `Scoreboard` class is initialized with a capacity, creating an array to hold `GameEntry` objects.",
                code: `public class Scoreboard {
  private int numEntries = 0;
  private GameEntry[] board;

  public Scoreboard(int capacity) {
    board = new GameEntry[capacity];
  }
}`,
                action: initializeState
            },
            {
                title: "Adding Initial Entries",
                text: "We populate the scoreboard. This `add` method is the core logic for inserting new scores while maintaining sorted order.",
                code: `public void add(GameEntry e) {
  int newScore = e.getScore();
  if (numEntries < board.length || newScore > board[numEntries-1].getScore()) {
    if (numEntries < board.length) {
      numEntries++;
    }
    int j = numEntries - 1;
    while (j > 0 && board[j-1].getScore() < newScore) {
      board[j] = board[j-1];
      j--;
    }
    board[j] = e;
  }
}`,
                action: populateInitialBoard
            },
            {
                title: "Adding a High Score",
                text: "A new entry, 'Jill' (740), arrives. The first step is to check if it's a high score. Since the board isn't full and 740 is higher than the last score (510), it qualifies.",
                code: `public void add(GameEntry e) {
  int newScore = e.getScore();
  // is the new entry e really a high score?
  if (numEntries < board.length || newScore > board[numEntries-1].getScore()) {
    // ... code to shift and add
  }
}`,
                action: introduceNewEntry
            },
            {
                title: "Making Room for the New Score",
                text: "To make room, we shift lower scores to the right. The `while` loop compares the new score with existing ones and shifts elements one by one.",
                code: `// shift any lower scores rightward
int j = numEntries - 1;
while (j > 0 && board[j-1].getScore() < newScore) {
  board[j] = board[j-1]; // shift entry from j-1 to j
  j--;
}`,
                action: shiftElementsForInsertion
            },
            {
                title: "Completing the Insertion",
                text: "Once the shifting is complete, the correct position `j` is found, and the new entry is placed into the array.",
                code: `// when done, add new entry
board[j] = e;`,
                action: insertNewEntry
            },
            {
                title: "Removing an Entry",
                text: "Let's remove 'Paul'. First, we must find the index of this entry. A loop would iterate through the array to find the matching object.",
                code: `public GameEntry remove(int i) {
  if (i < 0 || i >= numEntries) {
    throw new IndexOutOfBoundsException("Invalid index: " + i);
  }
  GameEntry temp = board[i]; // save the object to be removed
  // ... code to shift elements left
  return temp;
}`,
                action: highlightForRemoval
            },
             {
                title: "Closing the Gap",
                text: "After removing, a gap is left. We shift all subsequent elements one position to the left to keep the array contiguous.",
                code: `// shift elements left to fill gap
for (int j=i; j < numEntries - 1; j++) {
  board[j] = board[j+1];
}
board[numEntries - 1] = null; // null out old last entry
numEntries--;`,
                action: shiftElementsForRemoval
            },
            {
                title: "The Final State",
                text: "The removal is complete. The array is now shorter by one element but remains sorted and contiguous. This concludes our demonstration of basic array operations.",
                code: `// The scoreboard is now updated.
// numEntries has been decremented.
// The array is ready for the next operation.`,
                action: () => {}
            }
        ];

        const slidesContainer = document.getElementById('slides-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const resetBtn = document.getElementById('reset-btn');

        function updateUI() {
            const slideData = slides[currentSlide];
            slidesContainer.style.opacity = 0;
            setTimeout(() => {
                let codeHtml = '';
                if (slideData.code) {
                    codeHtml = `
                    <div class="slide-code">
                        <pre><code class="java hljs">${slideData.code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>
                    </div>`;
                }

                slidesContainer.innerHTML = `
                    <div class="slide-content" style="grid-template-columns: ${slideData.code ? '1fr 1fr' : '1fr'};">
                        <div class="slide-text">
                            <h2 class="text-2xl font-bold text-cyan-300 mb-2">${slideData.title}</h2>
                            <p class="text-gray-200">${slideData.text}</p>
                        </div>
                        ${codeHtml}
                    </div>`;

                if(slideData.code) {
                    hljs.highlightAll();
                }

                slidesContainer.style.opacity = 1;
            }, 500);

            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === slides.length - 1;

            if (slideData.action) {
                slideData.action();
            }
        }

        prevBtn.addEventListener('click', () => {
            if (currentSlide > 0) {
                currentSlide--;
                // We need to rebuild the state up to this slide
                resetScene();
                for(let i=0; i <= currentSlide; i++){
                    slides[i].action();
                }
                updateUI();
            }
        });


        nextBtn.addEventListener('click', () => {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                updateUI();
            }
        });

        resetBtn.addEventListener('click', () => {
            currentSlide = 0;
            resetScene();
            updateUI();
        });

        function resetScene() {
            // Cancel any ongoing animations on the objects being removed
            entryObjects.forEach(obj => gsap.killTweensOf(obj.position));
            
            entryObjects.forEach(obj => scene.remove(obj));
            entryObjects.length = 0;

            if (newEntryObject && newEntryObject.parent) {
                gsap.killTweensOf(newEntryObject.position);
                scene.remove(newEntryObject);
                newEntryObject = null;
            }
        }

        // --- SLIDE ACTION FUNCTIONS ---

        function initializeState() {
           // Scene is already clear at the start/reset
        }
        
        const initialData = [
            { name: "Mike", score: 1105 }, { name: "Rob", score: 750 },
            { name: "Paul", score: 720 }, { name: "Anna", score: 660 },
            { name: "Rose", score: 590 }, { name: "Jack", score: 510 }
        ];

        function populateInitialBoard() {
             resetScene();
             initialData.forEach((data, index) => {
                const entry = createEntryObject(data.name, data.score);
                const slot = boardSlots[index];
                entry.position.copy(slot.position);
                entry.position.y += SLOT_SIZE / 2;
                scene.add(entry);
                entryObjects.push(entry);
            });
        }
        
        let newEntryObject;
        function introduceNewEntry() {
            // Rebuild state without this slide's object
            populateInitialBoard();
            if (newEntryObject && newEntryObject.parent) {
                 scene.remove(newEntryObject);
            }

            newEntryObject = createEntryObject("Jill", 740);
            newEntryObject.position.set(0, 5, 5); // Appear from above
            scene.add(newEntryObject);
        }

        function shiftElementsForInsertion() {
            // Find insertion point
            const insertionIndex = 2; // Hardcoded based on data: after Mike (1105), Rob (750) and before Paul(720)

            // Animate shift
            const tl = gsap.timeline();
            for (let i = entryObjects.length - 1; i >= insertionIndex; i--) {
                const objToMove = entryObjects.find(o => o.position.x === boardSlots[i].position.x);
                 if (objToMove) {
                    const targetSlot = boardSlots[i + 1];
                    tl.to(objToMove.position, {
                        x: targetSlot.position.x,
                        duration: 0.5,
                        ease: "power2.inOut"
                    }, "-=0.2");
                }
            }
        }

        function insertNewEntry() {
            const insertionIndex = 2;
            const targetSlot = boardSlots[insertionIndex];
            if(newEntryObject) {
                 gsap.to(newEntryObject.position, {
                    x: targetSlot.position.x,
                    y: targetSlot.position.y + SLOT_SIZE / 2,
                    z: targetSlot.position.z,
                    duration: 1,
                    ease: "bounce.out",
                    onComplete: () => {
                        // Officially add to the array for state tracking after animation
                        const currentObjectsInScene = entryObjects.map(e => e.userData.name);
                        if (!currentObjectsInScene.includes("Jill")) {
                            entryObjects.splice(insertionIndex, 0, newEntryObject);
                        }
                    }
                });
            }
        }
        
        function highlightForRemoval() {
            // Find Paul's object
            const objectToHighlight = entryObjects.find(o => o.userData.name === 'Paul');
            if (objectToHighlight) {
                // Animate highlight (e.g., move up and change color)
                gsap.to(objectToHighlight.position, { y: objectToHighlight.position.y + 2, duration: 0.5 });
                objectToHighlight.children[0].material.color.set(0xff4444); // Highlight body
            }
        }

        function shiftElementsForRemoval() {
             const removalIndex = entryObjects.findIndex(o => o.userData.name === 'Paul');
             if (removalIndex === -1) return;

             const objectToRemove = entryObjects[removalIndex];

             // Animate removal
            gsap.to(objectToRemove.position, { y: objectToRemove.position.y + 10, duration: 1});
            gsap.to(objectToRemove.rotation, { y: Math.PI * 2, duration: 1, onComplete: () => {
                scene.remove(objectToRemove);
            }});


            // Animate shift
            const tl = gsap.timeline({delay: 0.5});
            for (let i = removalIndex + 1; i < entryObjects.length; i++) {
                const objectToMove = entryObjects[i];
                const targetSlot = boardSlots[i - 1];
                 tl.to(objectToMove.position, {
                    x: targetSlot.position.x,
                    duration: 0.5,
                    ease: "power2.inOut"
                }, "-=0.3");
            }

            // Update internal array
             entryObjects.splice(removalIndex, 1);
        }


        // --- INITIALIZATION ---
        initThreeJS();
        updateUI();

    </script>
</body>
</html>